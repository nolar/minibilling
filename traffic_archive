#!/bin/sh
#
# (a) 2006 nolar@numeri.net
#
# Этот скрипт просто упаковывает все файлы с трафиком для заданного интерфейса,
# которые находятся в архивном каталоге, в один сжатый файл. Имя файл формируется
# из текущего времени (времени упаковки) и имени интерфейса. Частота упаковки
# задается где-нибудь извне, например в cron. В один и тот же момент времени для
# одного интерфейса работает только один процесс упаковки, так что наложения архивов
# не случится. А за счет предварительной подготовки списка файлов, которые будут
# упакованы, не случится и потери данных. Исключая, конечно, случаи сбоя файловой
# системы из-за, например, внезапных перезагрузок системы, скачков питания и т.п.
#
# Первым и обязательным параметром принимает имя файла с настройками.
#

# Подключаем конфиг. Должен быть указан!
[ -f "$1" -a -r "$1" ] || { echo "Must specify config file as first parameter."	>&2; exit 3; }
. "$1"

# Проверяем что каталоги существуют, что они читабельны и доступны на запись.
[ -z "$lckdir" ] && { echo "Lock directory does not specified. Bye."		>&2; exit 2; }
[ -d "$lckdir" ] || { echo "Directory '$lckdir' does not exist. Bye."		>&2; exit 2; }
[ -r "$lckdir" ] || { echo "Directory '$lckdir' is not readable. Bye."		>&2; exit 2; }
[ -w "$lckdir" ] || { echo "Directory '$lckdir' is not writeable. Bye."		>&2; exit 2; }
[ -z "$olddir" ] && { echo "Old-traffic directory does not specified. Bye."	>&2; exit 2; }
[ -d "$olddir" ] || { echo "Directory '$olddir' does not exist. Bye."		>&2; exit 2; }
[ -r "$olddir" ] || { echo "Directory '$olddir' is not readable. Bye."		>&2; exit 2; }
[ -w "$olddir" ] || { echo "Directory '$olddir' is not writeable. Bye."		>&2; exit 2; }
[ -z "$pakdir" ] && { echo "Packed-traffic directory does not specified. Bye."	>&2; exit 2; }
[ -d "$pakdir" ] || { echo "Directory '$pakdir' does not exist. Bye."		>&2; exit 2; }
[ -r "$pakdir" ] || { echo "Directory '$pakdir' is not readable. Bye."		>&2; exit 2; }
[ -w "$pakdir" ] || { echo "Directory '$pakdir' is not writeable. Bye."		>&2; exit 2; }

# Проверяем наличие нужных нам параметров настройки.
[ -z "$identifier" ] && { echo "Identifier does not specified. Bye."		>&2; exit 2; }

# Защищаем файлы с сырым трафиком от стороннего их прочтения. Просто защиты по правам
# каталогов недостаточно, так как пользователи системы могут создать жесткий линк на
# i-node файла, и получить к нему доступ, если с файла явно не сняты общие права.
umask 077

# Проверяем, было ли указано вторым параметром ключевое (не секретное, а просто ключевое)
# слово. Если это слово было указано, то мы считаем что нас запустили на упаковку всех
# архивных файлов с трафиком, какие мы сможем найти, в один упакованный файл архива.
# Причем обо всех lock'ах уже позаботились и вторая копия скрипта не запустится.
if [ "$2" = "do" ] ; then

	# Заранее составляем список всех файлов с трафиком, которые мы будем упаковывать.
	# Это нужно сделать чтобы все дальнейшие операции происходили над одним и тем же
	# набором файлов, а не составлялись бы каждый раз по маске. Иначе мы рискуем,
	# например, удалить лишние файлы трафика, которые появятся пока мы будем паковать
	# имеющиеся.
	list=`find "$olddir" -name "*.$identifier.?.*.data" -execdir echo "{}" \;` \
		|| { echo "Failed to enumerate files in '$olddir'."		>&2; exit 1; }

	# Составляем уникальное имя для файла упакованного архива из текущей даты-времени
	# и имени интерфейса, для которого собирался трафик.
	stamp=`date +%Y%m%d%H%M%S` \
		|| { echo "Failed to get current stamp."			>&2; exit 1; }
	pakfile="$pakdir/$stamp.$identifier.tar"

	# Создаем или пересоздаем этот файл. Перед созданием удаляем его, чем бы он ни был.
	{ [ ! -e "$pakfile" ] || rm -rf "$pakfile"; }	\
		|| { echo "Failed to remove '$pakfile'."			>&2; exit 1; }
	touch "$pakfile" \
		|| { echo "Failed to create file '$pakfile'."			>&2; exit 1; }

	# Перебираем все архивные файлы трафика и для каждого запускаем упаковку.
	# Не запускаем упаковку по маске, потому что развертка маски может оказаться
	# совсем уж большой, и все файлы не влезут в длину команды (случается когда есть
	# несколько тысяч файлов).
	for file in $list ; do
		tar -r -f "$pakfile" -C "$olddir" "$file" \
		|| { echo "Failed to put '$olddir/$file' into '$pakfile'."	>&2; exit 1; }
	done

	# Сжимаем упакованный файл архива.
	gzip --best --force --suffix ".gz" "$pakfile" \
		|| { echo "Failed to gzip file '$pakfile'."			>&2; exit 1; }

	# Когда все операции успешно завершены, стираем те архивные файлы, которые мы
	# упаковали. Для этого нам снова пригодится составленный заранее список файлов.
	for file in $list ; do
		rm -rf "$olddir/$file" \
		|| { echo "Can not remove '$olddir/$file'. POSSIBLE DUPLICATE TRAFFIC IN ARCHIVES!" >&2; }
	done

	# Успешно выходим.
	exit 0

# Если же нас запустили без правильного второго параметра, то считаем что мы
# должны организовать все необходимые lock'и и перезапустить себя с правильным
# ключевым словом во втором параметре.
else

	# Составляем уникальное имя для lock-файла.
	lckfile="$lckdir/archive.$identifier.lock"

	# Запускаем себя же, но уже под lock'ом , чтобы избежать параллельных архиваций
	# трафика того же интерфейса, что и мы сами. Иначе будет плохо.
	lockf -k -s -t 0 "$lckfile" "$0" "$1" "do"

	# Запоминаем с каким статусом вышел основной скрипт.
	status="$?"

	# Выходим с запомненным ранее статусом основного скрипта.
	exit "$status"

fi

#
# Все.
#